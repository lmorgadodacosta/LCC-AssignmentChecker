#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sqlite3, datetime
from flask import Flask, current_app, url_for
from flask_login import LoginManager, UserMixin, login_required, login_user, logout_user, current_user, wraps
from itsdangerous import URLSafeTimedSerializer # for safe session cookies
from hashlib import md5

from common_sql import *

app = Flask(__name__)
with app.app_context():

    login_manager = LoginManager()
    login_manager.login_view = '/login'
    login_manager.login_message = "You don't seem to have permission to see this content."
    app.secret_key = "!$flhgSgngNO%$#SOET!$!"
    app.config["REMEMBER_COOKIE_DURATION"] = datetime.timedelta(minutes=30)
    login_serializer = URLSafeTimedSerializer(app.secret_key)


    def hash_pass(password):
        """ Return the md5 hash of the password+salt """
        salted_password = password + app.secret_key
        return md5(salted_password.encode('utf-8')).hexdigest()


    def login_required(role=0, group='open'):
        """
        This is a redefinition of the decorator login_required,
        to include a 'role' argument to allow users with different
        roles access different views and a group access to close some
        views by groups. For example:
        @login_required(role=0, group='ntuwn')   0 = for all
        """
        def wrapper(fn):
            @wraps(fn)
            def decorated_view(*args, **kwargs):
                if not current_user.is_authenticated:
                    return login_manager.unauthorized()
                if current_user.role < role:
                    return login_manager.unauthorized()
                if group != 'open' and current_user.group != group:
                    return login_manager.unauthorized()

                return fn(*args, **kwargs)
            return decorated_view
        return wrapper


    class User(UserMixin):
        def __init__(self, userID, password, role, group):
            self.id = userID
            self.password = password
            self.role = role
            self.group = group

        def get_auth_token(self):
            """ Encode a secure token for cookie """
            data = [str(self.id), self.password]
            return login_serializer.dumps(data)

        def get_role(self):
            """ Returns the role (access level) for the user """
            return self.role

        @staticmethod
        def get(userid):
            """
            Static method to search the database and see if userid exists.
            If it does exist then return a User Object. If not then return
            None, as required by Flask-Login.
            """
            user = fetch_userid(userid)

            if user:
                return User(user[0], user[1], user[2], user[3])
            else:
                return None


    @login_manager.user_loader
    def load_user(userID):
        """ This function, given an user_id, needs to check whether this user
        'is active' / 'exists' [FIXME, this should be done against the DB?],
        and returns an User object. I DONT THINK SO ANYMORE!"""

        """
        Flask-Login user_loader callback.
        The user_loader function asks this function to get a User Object or return
        None based on the userid.
        The userid was stored in the session environment by Flask-Login.
        user_loader stores the returned User object in current_user during every
        flask request.
        """
        return User.get(userID)


    @login_manager.token_loader
    def load_token(token):
        """
        Flask-Login token_loader callback.
        The token_loader function asks this function to take the token that was
        stored on the users computer process it to check if its valid and then
        return a User Object if its valid or None if its not valid.
        """

        #The Token itself was generated by User.get_auth_token.  So it is up to
        #us to known the format of the token data itself.

        #The Token was encrypted using itsdangerous.URLSafeTimedSerializer which
        #allows us to have a max_age on the token itself.  When the cookie is stored
        #on the users computer it also has a exipry date, but could be changed by
        #the user, so this feature allows us to enforce the exipry date of the token
        #server side and not rely on the users cookie to expire.
        max_age = app.config["REMEMBER_COOKIE_DURATION"].total_seconds()

        #Decrypt the Security Token, data = [username, hashpass]
        data = login_serializer.loads(token, max_age=max_age)

        #Find the User
        user = User.get(data[0])

        #Check Password and return user or None
        if user and data[1] == user.password:
            return user
        return None
